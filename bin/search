#!/bin/sh
# search: fuzzy finder based on fzf that works with Apps Files Passwords and open Windows.

set -o errexit
set -o nounset

# Default pass password store directory
PASSWORD_STORE=".password-store"
BOOKMARK_FILE="$PASSWORD_STORE/bookmarks/bookmarks.html"

# Preload incoming queries
if [ $# -eq 0 ]; then
	QUERY="Search"
else
	QUERY=$1
fi

# FUZZER="$HOME/.local/bin/fzf/bin/fzf --color=bw --prompt=$QUERY --reverse --query '"
FUZZER="rofi -dmenu -i -theme Arc-Dark -p $QUERY"

if [ "$(uname)" = "Darwin" ]; then
	GREP="/usr/local/bin/ggrep"
	PASS="/usr/local/bin/pass"
	CLIP="pbcopy"
elif [ "$(uname)" = "Linux" ]; then
	GREP="/bin/grep"
	PASS="/bin/pass"
	CLIP="xclip -loops 0 -sel p -sel s -sel c"
else
	echo "Unsupported OS"
	exit 1
fi

handle_password() {
	RESP_PASS=$(
		cat <<EOF | $FUZZER
Password
Username
OTP
EOF
	)

	case "$RESP_PASS" in

	Username)

		PASSDATA=$($PASS "$RESULT")
		USRNAME="$(echo "$PASSDATA" | $GREP -Ei "login:|username:|user:" | head -1 | cut -d' ' -f2-)"
		printf '%s' "$USRNAME" | nohup $CLIP &
		;;

	Password)

		PASSDATA=$($PASS "$RESULT" | head -n1)
		printf '%s' "$PASSDATA" | nohup $CLIP &
		;;

	OTP)

		PASSDATA=$($PASS otp "$RESULT" | head -n1)
		printf '%s' "$PASSDATA" | nohup $CLIP &
		;;

	*)

		exit 1
		;;

	esac
}

prepare_data() {
	# Find all files using ripgrep
	# Exclude some of the unwanted folders
	if [ "$QUERY" = "Search" ] || echo "$QUERY" | $GREP -q Files; then
		cd ~ || exit
		find -L -- ~ 2>/dev/null |
			$GREP -Ev 'node_modules|\.git|flatpak|\.cache|\.local/lib|\.local/share' |
			sed 's/^/Files: /g'
	fi

	# Fetch password list
	if [ "$QUERY" = "Search" ] || echo "$QUERY" | $GREP -q Password; then
		cd ~ || exit
		find $PASSWORD_STORE/ -type f -name "*.gpg" 2>/dev/null |
			$GREP -Ev 'node_modules|\.git|flatpak|\.cache|\.local/lib|\.local/share' |
			sed 's/^/Password: /g' |
			sed "s/$PASSWORD_STORE\///g" |
			sed "s/\.gpg//g"
	fi

	if [ "$QUERY" = "Search" ] || echo "$QUERY" | $GREP -Eq "Bookmarks|Password"; then
		cd ~ || exit
		for line in $(cat "$BOOKMARK_FILE"); do
			bookmark=$(echo "$line" | $GREP -oP 'HREF="\Khttp[^"]+' || :)
			if [ "$bookmark" != "" ]; then
				title=$($GREP "$bookmark"Search"$BOOKMARK_FILE" | $GREP -Eo '">.*</A>' | $GREP -oP '>\K[^<]+' | $GREP -v 'Recent Tags')
				echo "Bookmarks: $title | $bookmark "
			fi
		done
	fi

	if [ "$QUERY" = "Search" ] || echo "$QUERY" | $GREP -q Program; then
		# Fetch executables from PATH
		if [ ! -f ~/.cache/desktop-files ] || test "$(find ~/.cache/desktop-files -mmin +30)"; then
			# We do not have a cache file, let's create it!
			echo "Program: Refresh Apps | "
			echo "Refresh Apps | " >>~/.cache/desktop-files
			for file in $(find \
				~/.local/share/applications/ \
				~/.local/share/flatpak/app/*/current/active/export/ \
				~/Programs/ \
				/usr/share/applications/ \
				-iname '*.desktop' 2>/dev/null |
				$GREP -Ev 'xdg|session|autostart|\.stversions' |
				sort -u); do

				if [ -f "$file" ]; then

					name=$($GREP '^Name=' "$file" | head -1 | sed 's/^Name=//g')
					generic_name=$($GREP '^GenericName=' "$file" | head -1 | sed 's/^GenericName=//g' | sed 's/%.*//g')
					categories_names=$($GREP '^Categories=' "$file" | head -1 | sed 's/^Categories=//g' | sed 's/%.*//g' | sed 's/;/ /g')
					command_name=$($GREP '^Exec=' "$file" | head -1 | sed 's/^Exec=//g' | sed 's/%.*//g')
					# Save name in file, this will be used for fzf
					echo "$name | $command_name | $generic_name | $categories_names" >>~/.cache/desktop-files
					echo "Program: $name | $command_name | $generic_name | $categories_names"

				fi
			done
		else
			# Aggregate with other data
			sort -u ~/.cache/desktop-files | sed 's/^/Program: /g'
		fi
	fi

	if [ "$QUERY" = "Search" ] || echo "$QUERY" | $GREP -Eq "Window|Program"; then
		# Fetch open windows
		wmctrl -l | $GREP -o "$(hostname).*" | sed "s/$(hostname) /Window: /g"
	fi
}

main() {
	# Present on fzf
	RESULT=$(prepare_data | $FUZZER)
	if [ -z "$RESULT" ]; then
		exit 0
	fi

	if echo "$RESULT" | $GREP -q "^Window"; then

		### Focus target window
		RESULT=$(echo "$RESULT" | cut -d":" -f2 | awk '{$1=$1};1')
		wmctrl -a "$RESULT"

	elif echo "$RESULT" | $GREP -q "^Program"; then

		### Execute the file
		RESULT=$(echo "$RESULT" | cut -d":" -f2 | awk '{$1=$1};1')
		if [ "$RESULT" = "Refresh Apps |" ]; then
			rm ~/.cache/desktop-files
			return
		fi
		# Retrieve original file name
		command_exec=$(echo "$RESULT" | cut -d"|" -f2 | awk '{$1=$1};1')
		# Exec
		setsid -f $command_exec >/dev/null 2>&1 &

	elif echo "$RESULT" | $GREP -q "^Password"; then

		### Handle the password
		RESULT=$(echo "$RESULT" | cut -d":" -f2 | awk '{$1=$1};1')
		handle_password

	elif echo "$RESULT" | $GREP -q "^Bookmark"; then

		RESULT=$(echo "$RESULT" | cut -d"|" -f2 | awk '{$1=$1};1')
		setsid -f xdg-open "$RESULT" >/dev/null 2>&1 &

	else

		### Open the file using MIME recognition
		RESULT=$(echo "$RESULT" | cut -d":" -f2 | awk '{$1=$1};1')
		setsid -f xdg-open "$RESULT" >/dev/null 2>&1 &
	fi
	sleep 0.3
}

main
