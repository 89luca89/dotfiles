#!/bin/sh
# search: fuzzy finder based on fzf that works with Apps Files Passwords and open Windows.

set -o errexit
set -o nounset

# Default pass password store directory
PASSWORD_STORE=".password-store"
BOOKMARK_FILE="$PASSWORD_STORE/bookmarks/bookmarks.html"

# Preload incoming queries
if [ $# -eq 0 ]; then
	QUERY=" "
else
	QUERY=$1
fi

FZF="/home/luca-linux/.local/bin/fzf/bin/fzf --color=bw --prompt=$QUERY --border --reverse --query '"

handle_password() {
	RESP_PASS=$(
		cat <<EOF | $FZF
Password
Username
OTP
EOF
	)

	case "$RESP_PASS" in

	Username)

		PASSDATA=$(/bin/pass "$RESULT")
		USRNAME="$(echo "$PASSDATA" | grep -Ei "login:|username:|user:" | head -1 | cut -d' ' -f2-)"
		printf '%s' "$USRNAME" | nohup xclip -loops 0 -sel p -sel s -sel c &
		;;

	Password)

		PASSDATA=$(/bin/pass "$RESULT" | head -n1)
		printf '%s' "$PASSDATA" | nohup xclip -loops 0 -sel p -sel s -sel c &
		;;

	OTP)

		PASSDATA=$(/bin/pass otp "$RESULT" | head -n1)
		printf '%s' "$PASSDATA" | nohup xclip -loops 0 -sel p -sel s -sel c &
		;;

	*)

		exit 1
		;;

	esac
}

prepare_data() {
	# Find all files using ripgrep
	# Exclude some of the unwanted folders
	if [ "$QUERY" = " " ] || echo "$QUERY" | grep -q Files; then
		cd ~ || exit
		find -L -- * 2>/dev/null |
			grep -Ev 'node_modules|\.git|flatpak|\.cache|\.local/lib|\.local/share' |
			sed 's/^/Files: /g'
	fi

	# Fetch password list
	if [ "$QUERY" = " " ] || echo "$QUERY" | grep -q Password; then
		cd ~ || exit
		find $PASSWORD_STORE/ -type f -name "*.gpg" 2>/dev/null |
			grep -Ev 'node_modules|\.git|flatpak|\.cache|\.local/lib|\.local/share' |
			sed 's/^/Password: /g' |
			sed "s/$PASSWORD_STORE\///g" |
			sed "s/\.gpg//g"
	fi

	if [ "$QUERY" = " " ] || echo "$QUERY" | grep -Eq "Bookmarks|Password"; then
		cd ~ || exit
		for line in $(cat "$BOOKMARK_FILE"); do
			bookmark=$(echo "$line" | grep -oP 'HREF="\Khttp[^"]+' || :)
			if [ "$bookmark" != "" ]; then
				title=$(grep "$bookmark" "$BOOKMARK_FILE" | grep -Eo '">.*</A>' | grep -oP '>\K[^<]+' | grep -v 'Recent Tags')
				echo "Bookmarks: $title | $bookmark "
			fi
		done
	fi

	if [ "$QUERY" = " " ] || echo "$QUERY" | grep -q Program; then
		# Fetch executables from PATH
		# We do not have a cache file, let's create it!
		for file in $(find \
			~/.local/share/applications/ \
			~/.local/share/flatpak/app/*/current/active/export/ \
			~/Programs/ \
			/usr/share/applications/ \
			-iname '*.desktop' 2>/dev/null |
			grep -Ev 'xdg|session|autostart|\.stversions' |
			sort -u); do

			if [ -f "$file" ]; then

				name=$(grep '^Name=' "$file" | head -1 | sed 's/^Name=//g')
				generic_name=$(grep '^GenericName=' "$file" | head -1 | sed 's/^GenericName=//g' | sed 's/%.*//g')
				categories_names=$(grep '^Categories=' "$file" | head -1 | sed 's/^Categories=//g' | sed 's/%.*//g' | sed 's/;/ /g')
				command_name=$(grep '^Exec=' "$file" | head -1 | sed 's/^Exec=//g' | sed 's/%.*//g')
				# Save name in file, this will be used for fzf
				echo "$name | $command_name | $generic_name | $categories_names" >>~/.cache/desktop-files
				echo "Program: $name | $command_name | $generic_name | $categories_names"

			fi
		done
	fi

	if [ "$QUERY" = " " ] || echo "$QUERY" | grep -Eq "Window|Program"; then
		# Fetch open windows
		wmctrl -l | grep -o "$(hostname).*" | sed "s/$(hostname) /Window: /g"
	fi
}

main() {
	# Present on fzf
	RESULT=$(prepare_data | $FZF)
	if [ -z "$RESULT" ]; then
		exit 0
	fi

	if echo "$RESULT" | grep -q "^Window"; then

		### Focus target window
		RESULT=$(echo "$RESULT" | cut -d":" -f2 | awk '{$1=$1};1')
		wmctrl -a "$RESULT"

	elif echo "$RESULT" | grep -q "^Program"; then

		### Execute the file
		RESULT=$(echo "$RESULT" | cut -d":" -f2 | awk '{$1=$1};1')
		# Retrieve original file name
		command_exec=$(echo "$RESULT" | cut -d"|" -f2 | awk '{$1=$1};1')
		# Exec
		setsid -f $command_exec >/dev/null 2>&1 &

	elif echo "$RESULT" | grep -q "^Password"; then

		### Handle the password
		RESULT=$(echo "$RESULT" | cut -d":" -f2 | awk '{$1=$1};1')
		handle_password

	elif echo "$RESULT" | grep -q "^Bookmark"; then

		RESULT=$(echo "$RESULT" | cut -d"|" -f2 | awk '{$1=$1};1')
		setsid -f xdg-open "$RESULT" >/dev/null 2>&1 &

	else

		### Open the file using MIME recognition
		RESULT=$(echo "$RESULT" | cut -d":" -f2 | awk '{$1=$1};1')
		setsid -f xdg-open "$RESULT" >/dev/null 2>&1 &
	fi
	sleep 0.3
}

main
